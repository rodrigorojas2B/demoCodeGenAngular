name: Generar funcionalidad desde historia de usuario

on:
  push:
    paths:
      - 'historias-usuario/**/*.yml'
      - 'postman/api_collection.json'
      - 'diseno/**/*.json'

jobs:
  generar_codigo:
    runs-on: ubuntu-latest
    env:
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

    steps:
      - name: Clonar repositorio actual
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT }}
          path: repositorio-base

      - name: Detectar historia de usuario modificada
        id: historia
        run: |
          cd repositorio-base
          git fetch --unshallow || true
          base_sha="${{ github.event.before }}"
          if ! git cat-file -e "$base_sha"^{commit} 2>/dev/null; then
            echo "âš ï¸ SHA base no vÃ¡lido o sin historial, usando HEAD^"
            base_sha="HEAD^"
          fi
          echo "ğŸ” Comparando con base: $base_sha"
          archivo=$(git diff --name-only "$base_sha" HEAD | grep '^historias-usuario/.*\.yml$' | head -n 1 || true)
          if [ -z "$archivo" ]; then
            echo "â›” No se encontrÃ³ ninguna historia de usuario modificada. Abortando."
            exit 1
          fi
          echo "ruta=$archivo" >> "$GITHUB_OUTPUT"
          echo "base=$base_sha" >> "$GITHUB_OUTPUT"

      - name: Leer contenido de historia de usuario
        run: |
          cd repositorio-base
          echo "ğŸ“ Historia detectada: ${{ steps.historia.outputs.ruta }}"
          cat "${{ steps.historia.outputs.ruta }}" > entrada_gpt.txt

      - name: Leer colecciÃ³n Postman
        run: |
          cd repositorio-base
          if [ ! -f "postman/api_collection.json" ]; then
            echo "â›” Archivo postman/api_collection.json no encontrado. Abortando."
            exit 1
          fi
          echo "ğŸ“¦ API Postman detectada"
          cp postman/api_collection.json entrada_api.json

      - name: Detectar y copiar diseÃ±o JSON
        id: diseno
        run: |
          cd repositorio-base
          diseno=$(find diseno -name '*.json' | sort | head -n 1)
          if [ -z "$diseno" ]; then
            echo "â›” No se encontrÃ³ ningÃºn archivo de diseÃ±o en la carpeta 'diseno'. Abortando."
            exit 1
          fi
          echo "ğŸ¨ DiseÃ±o encontrado: $diseno"
          cat "$diseno" > entrada_diseno.json

      - name: Detectar y listar componentes Angular existentes
        id: listar_componentes
        run: |
          cd repositorio-base

          echo "ğŸ“¦ Buscando componentes Angular existentes..."

          lista=$(find src/app -type f \( -name "*.component.ts" -o -name "*.component.html" -o -name "*.service.ts" \) | sort)

          if [ -z "$lista" ]; then
            echo "âš ï¸ No se encontraron componentes existentes."
          else
            echo "ğŸ§© Componentes encontrados:"
            echo "$lista"
            echo "$lista" > componentes_existentes.txt
          fi

      - name: Verificar que OPENAI_API_KEY estÃ¡ disponible
        run: |
          if [ -z "$OPENAI_API_KEY" ]; then
            echo "âŒ OPENAI_API_KEY no estÃ¡ definida. Revisa los secretos del repositorio."
            exit 1
          else
            echo "âœ… OPENAI_API_KEY presente con longitud: ${#OPENAI_API_KEY}"
          fi

      - name: Analizar historias de usuario y determinar APIs utilizables
        run: |
          cd repositorio-base

          echo "ğŸ“Œ Preparando anÃ¡lisis de APIs disponibles para las historias de usuario..."

          echo -e "\n\n--- HISTORIA DE USUARIO ---" > prompt_apis.txt
          cat entrada_gpt.txt >> prompt_apis.txt

          echo -e "\n\n--- ESPECIFICACIÃ“N API POSTMAN ---" >> prompt_apis.txt
          cat entrada_api.json >> prompt_apis.txt

          echo -e "\n\n--- INSTRUCCIONES ---" >> prompt_apis.txt
          cat <<'EOF' >> prompt_apis.txt

          Tu tarea es analizar cada historia de usuario y determinar si puede ser implementada usando alguno de los endpoints definidos en la colecciÃ³n Postman (API REST).

          Para cada historia:
          - Indica si hay uno o mÃ¡s endpoints que la cubran.
          - Si sÃ­, especifica:
            - MÃ©todo (GET, POST, etc.)
            - Ruta
            - ParÃ¡metros requeridos
            - Observaciones (si necesita filtros, transformaciones, etc.)
          - Si no hay cobertura adecuada, indÃ­calo claramente.

          Entrega los resultados en tabla Markdown:

          | Historia | MÃ©todo | Endpoint | ParÃ¡metros | Cobertura | ObservaciÃ³n |
          |----------|--------|----------|------------|-----------|-------------|
          EOF

          jq -Rs --arg SYSTEM_MSG "Eres un analista funcional que trabaja con colecciones Postman y HDUs." '{
            model: "gpt-4",
            messages: [
              { "role": "system", "content": $SYSTEM_MSG },
              { "role": "user", "content": . }
            ],
            temperature: 0.2
          }' prompt_apis.txt > payload_apis.json

          curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_apis.json > respuesta_apis.json

          ANALISIS=$(jq -r '.choices[0].message.content // empty' respuesta_apis.json)
          if [ -z "$ANALISIS" ]; then
            echo "âŒ No se recibiÃ³ anÃ¡lisis vÃ¡lido de APIs."
            exit 1
          fi
          echo "$ANALISIS" > analisis_apis.txt

      - name: Mostrar anÃ¡lisis de APIs
        run: |
          echo "ğŸ“‹ Tabla de anÃ¡lisis de cobertura de APIs:"
          cat repositorio-base/analisis_apis.txt

      - name: DiagnÃ³stico de componentes Angular (usando APIs mapeadas)
        run: |
          cd repositorio-base

          if [ ! -f componentes_existentes.txt ]; then
            echo "âš ï¸ No existe 'componentes_existentes.txt'. Asumiendo que no hay componentes aÃºn."
            echo "(sin componentes disponibles)" > componentes_existentes.txt
          fi

          echo "ğŸ“¦ DiagnÃ³stico de componentes basado en APIs ya mapeadas..."

          echo -e "\n\n--- HISTORIA DE USUARIO ---" > prompt_componentes.txt
          cat entrada_gpt.txt >> prompt_componentes.txt

          echo -e "\n\n--- ANÃLISIS DE APIs DISPONIBLES ---" >> prompt_componentes.txt
          cat analisis_apis.txt >> prompt_componentes.txt

          echo -e "\n\n--- COMPONENTES EXISTENTES ---" >> prompt_componentes.txt
          cat componentes_existentes.txt >> prompt_componentes.txt

          echo -e "\n\n--- INSTRUCCIONES ---" >> prompt_componentes.txt
          cat <<'EOF' >> prompt_componentes.txt

          Tu tarea es analizar quÃ© componentes y servicios Angular deben usarse para implementar las historias de usuario, segÃºn el anÃ¡lisis previo de APIs.

          Entrega una tabla Markdown:

          | Archivo Angular | Tipo | ClasificaciÃ³n | API a usar | MÃ©todo | Endpoint | Motivo |
          |------------------|------|----------------|------------|--------|----------|--------|

          Si no hay componentes existentes, asume que deben crearse todos desde cero. NO generes cÃ³digo todavÃ­a.
          EOF

          jq -Rs --arg SYSTEM_MSG "Eres un arquitecto frontend Angular. Usa solo la informaciÃ³n provista." '{
            model: "gpt-4",
            messages: [
              { "role": "system", "content": $SYSTEM_MSG },
              { "role": "user", "content": . }
            ],
            temperature: 0.2
          }' prompt_componentes.txt > payload_componentes.json

          curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_componentes.json > respuesta_componentes.json

          DIAGNOSTICO=$(jq -r '.choices[0].message.content // empty' respuesta_componentes.json)
          if [ -z "$DIAGNOSTICO" ]; then
            echo "âŒ No se recibiÃ³ diagnÃ³stico vÃ¡lido de componentes."
            exit 1
          fi
          echo "$DIAGNOSTICO" > diagnostico_componentes.txt

      - name: Mostrar diagnÃ³stico de componentes
        run: |
          cd repositorio-base
          echo "ğŸ“‹ DiagnÃ³stico generado por GPT:"
          cat diagnostico_componentes.txt

      - name: Generar prompt para creaciÃ³n de cÃ³digo Angular (solo TS)
        run: |
          cd repositorio-base
      
          echo "ğŸ“Œ Preparando prompt para generaciÃ³n de cÃ³digo Angular (solo TS)..."
      
          echo -e "\n\n--- HISTORIA DE USUARIO ---" > prompt_ts.txt
          cat entrada_gpt.txt >> prompt_ts.txt
      
          echo -e "\n\n--- ANÃLISIS DE APIs DISPONIBLES ---" >> prompt_ts.txt
          cat analisis_apis.txt >> prompt_ts.txt
      
          echo -e "\n\n--- DIAGNÃ“STICO DE COMPONENTES ---" >> prompt_ts.txt
          cat diagnostico_componentes.txt >> prompt_ts.txt
      
          echo -e "\n\n--- INSTRUCCIONES ---" >> prompt_ts.txt
          cat <<'EOF' >> prompt_ts.txt
          
          Eres un generador de cÃ³digo Angular experto.
          
          Tu tarea es crear Ãºnicamente el cÃ³digo TypeScript (.ts) necesario para implementar las historias de usuario.
          
          Dispones de:
          - Las historias de usuario
          - El anÃ¡lisis de cobertura API
          - El diagnÃ³stico de componentes existentes y nuevos
          
          Para cada componente indicado como "NUEVO" o "MODIFICABLE":
          - Genera el archivo `.component.ts` o `.service.ts` correspondiente
          - Usa la arquitectura Angular standalone (sin NgModules)
          - AsegÃºrate de que los servicios llamen al endpoint apropiado indicado en el anÃ¡lisis de API
          - No modifiques los componentes clasificados como "REUTILIZABLE-AS-IS"
          
          Entrega los archivos envueltos entre delimitadores como:
          === archivo: ruta/archivo.component.ts ===
          ...contenido TypeScript...
          
          No incluyas HTML, CSS ni explicaciones. Solo cÃ³digo TypeScript vÃ¡lido, limpio y funcional.
          
          EOF
      
      - name: Llamar a OpenAI para generar cÃ³digo TS
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base
      
          echo "ğŸ“¨ Enviando prompt a OpenAI para generaciÃ³n de cÃ³digo TypeScript..."
      
          jq -Rs --arg SYSTEM_MSG "Eres un generador experto de aplicaciones Angular. Devuelve Ãºnicamente cÃ³digo TypeScript vÃ¡lido, sin explicaciones." '{
            model: "gpt-4",
            messages: [
              { "role": "system", "content": $SYSTEM_MSG },
              { "role": "user", "content": . }
            ],
            temperature: 0.2
          }' prompt_ts.txt > payload_ts.json
      
          echo "ğŸ“¤ Payload construido, enviando a OpenAI..."
      
          curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_ts.json > respuesta_ts.json
      
          echo "ğŸ“¥ Respuesta recibida."
      
          RESULTADO=$(jq -r '.choices[0].message.content // empty' respuesta_ts.json)
      
          if [ -z "$RESULTADO" ]; then
            echo "âŒ No se recibiÃ³ cÃ³digo vÃ¡lido desde OpenAI."
            exit 1
          fi
      
          echo "$RESULTADO" > codigo_ts_generado.txt
      
          echo "âœ… CÃ³digo TypeScript generado guardado en 'codigo_ts_generado.txt'"
      
      - name: Mostrar cÃ³digo TypeScript generado
        run: |
          echo "ğŸ“¦ CÃ³digo Angular (TS) generado:"
          cat repositorio-base/codigo_ts_generado.txt
    
      - name: Generar prompt para HTML y CSS (segÃºn diseÃ±o)
        run: |
          cd repositorio-base
      
          echo "ğŸ“Œ Preparando prompt para generaciÃ³n de HTML y CSS..."
      
          echo -e "\n\n--- HISTORIA DE USUARIO ---" > prompt_ui.txt
          cat entrada_gpt.txt >> prompt_ui.txt
      
          echo -e "\n\n--- DISEÃ‘O VISUAL / UI / ESTILOS ---" >> prompt_ui.txt
          cat entrada_diseno.json >> prompt_ui.txt
      
          echo -e "\n\n--- CÃ“DIGO TYPESCRIPT GENERADO ---" >> prompt_ui.txt
          cat codigo_angular_generado.txt >> prompt_ui.txt
      
          echo -e "\n\n--- INSTRUCCIONES ---" >> prompt_ui.txt
          cat <<'EOF' >> prompt_ui.txt
      
          Eres un generador experto de interfaces Angular. Tu tarea es:
          
          - Leer la historia de usuario, el diseÃ±o visual JSON, y el archivo `.ts` generado previamente.
          - Generar para cada componente Angular nuevo/modificado los archivos:
            - `.component.html`
            - `.component.css`
          - Los archivos deben seguir el diseÃ±o provisto (colores, fuentes, layout, botones, estructura).
          - Usa clases CSS reutilizables y coherentes con los tokens.
          - Si un componente ya tiene estructura declarada en el `.ts`, Ãºsala como base para el HTML.
          - No incluyas cÃ³digo TypeScript.
          - No des explicaciones ni comentarios fuera del cÃ³digo.
          - Usa los siguientes delimitadores:
            === archivo: src/app/components/nombre/nombre.component.html ===
            ...html...
            === archivo: src/app/components/nombre/nombre.component.css ===
            ...css...
          EOF
      
      - name: Llamar a OpenAI para generar HTML y CSS
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          cd repositorio-base
      
          echo "ğŸ“¨ Enviando prompt a OpenAI para generaciÃ³n de HTML y CSS..."
      
          jq -Rs --arg SYSTEM_MSG "Eres un generador experto de interfaces Angular. Devuelve Ãºnicamente cÃ³digo HTML y CSS limpio." '{
            model: "gpt-4",
            messages: [
              { "role": "system", "content": $SYSTEM_MSG },
              { "role": "user", "content": . }
            ],
            temperature: 0.2
          }' prompt_ui.txt > payload_ui.json
      
          curl -s https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer $OPENAI_API_KEY" \
            -H "Content-Type: application/json" \
            -d @payload_ui.json > respuesta_ui.json
      
          echo "ğŸ“¥ Respuesta recibida."
      
          UI_CODE=$(jq -r '.choices[0].message.content // empty' respuesta_ui.json)
      
          if [ -z "$UI_CODE" ]; then
            echo "âŒ No se recibiÃ³ cÃ³digo HTML/CSS vÃ¡lido desde OpenAI."
            exit 1
          fi
      
          echo "$UI_CODE" > codigo_ui_generado.txt
          echo "âœ… Archivos HTML y CSS generados correctamente."
      

      - name: Limpiar y separar archivos Angular generados
        run: |
          cd repositorio-base

          echo "ğŸ§¹ Limpiando residuos de formato GPT..."
          sed -i '/^---/d' codigo_angular_generado.txt
          sed -i '/^```.*$/d' codigo_angular_generado.txt
          sed -i '/^# .*$/d' codigo_angular_generado.txt
          sed -i '/^$/N;/^\n$/D' codigo_angular_generado.txt

          echo "ğŸ“ Contenido limpio antes de separar:"
          cat codigo_angular_generado.txt

          echo "ğŸ“‚ Separando en archivos individuales..."

          mkdir -p src/app/component

          csplit --quiet --prefix=tmp_ --suffix-format=%02d.txt codigo_angular_generado.txt "/^=== archivo: /" {*}

          for file in tmp_*.txt; do
            ruta=$(grep '^=== archivo:' "$file" | sed -E 's/^=== archivo: //;s/ ===$//')
            if [ -z "$ruta" ]; then
              echo "âš ï¸ No se pudo determinar ruta para $file. Saltando."
              continue
            fi

            echo "ğŸ“„ Generando archivo: $ruta"
            mkdir -p "$(dirname "$ruta")"
            tail -n +2 "$file" > "$ruta"
            rm "$file"
          done

          echo "âœ… Archivos generados:"
          find src/app/component -type f

      - name: Generar resumen de archivos creados
        run: |
          cd repositorio-base

          echo "ğŸ“‹ Resumen de archivos generados:" > resumen_generacion.txt
          {
            echo ""
            echo "=== COMPONENTES GENERADOS ==="
            find src/app/components -type f \( -name "*.ts" -o -name "*.html" -o -name "*.css" \) | sort

            echo ""
            echo "=== SERVICIOS GENERADOS ==="
            find src/app/services -type f -name "*.ts" | sort

            echo ""
            echo "=== MODELOS GENERADOS ==="
            find src/app/models -type f -name "*.ts" | sort || true
          } >> resumen_generacion.txt

          echo "ğŸ“ Contenido del resumen:"
          cat resumen_generacion.txt

      - name: Commit y push de los cambios generados
        env:
          GH_PAT: ${{ secrets.GH_PAT }}
        run: |
          cd repositorio-base

          git config user.name "github-actions"
          git config user.email "github-actions@github.com"
          git checkout main

          git add .

          if git diff --cached --quiet; then
            echo "âš ï¸ No hay cambios para commitear. Finalizando sin push."
            exit 0
          fi

          mensaje="ğŸ¤– CÃ³digo Angular generado automÃ¡ticamente desde historia de usuario + resumen"
          git commit -m "$mensaje"

          echo "ğŸ“¤ Haciendo push a main..."
          git push origin main
